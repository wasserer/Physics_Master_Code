from numpy import *
from pandas import *
from tkinter import filedialog
from tkinter import Tk
import os
import csv
from pathlib import Path
from scipy.interpolate import UnivariateSpline
from scipy.optimize import fsolve, fmin
import warnings

''' Post-Analysis of IV-Data from Solar Cell Measurements
    Author: Nikan Manschadi
    Last modified: 15.09.2023
    Description: The script analyses voltage-current data from a solar cell measurement. From the time stamps, the given
                 reference currents, the power density of the spectrum and the calibrated reference current, it calculates
                 the input power that the cell received. Then it interpolates the I-V data in order to calculate important
                 characteristics such as power conversion efficiency (PCE) or fill factor (FF).
                 There are two modi:
                 -  analyse a long term measurement series, where ONE cell was tested repeatedly. The script will then 
                    list the desired characteristics of each pixel of the cell in a separate file, ordered by time.
                 -  analyse a batch of different solar cells. The script will then create a file for each desired
                    characteristic, where the respective value is filled in a matrix (solar cell as row and pixel as 
                    column index)
    How to use:  Change the following global variables according to your data. "Batch" analysis will analyse a batch of 
                 solar cells, while "long_term" can deal with data only from one cell that was measured repeatedly. The
                 difference is mainly the file structure of the results: for "long_term" one file per pixel is created with
                 all desired parameters. For "batch", one file per parameter is created for all solar cells and pixels.
                 After starting the script, chose the folder containing the measurement files. Now the script will create a new file for each pixel detected
                 that lists the desired parameters given by "columns" over time. The time stamps are generated by looking
                 at the files modification time. Columns is a selection of values you can chose from "complete_list".
                 Note: if your using a different cell geometry, different reference cell or light spectrum adapt this in
                 the three parameters a bit lower. Please report bugs :) '''

'''----- Set the following parameters --------------------------------------------------------------------------------'''
ident = "N13"  # All files matching this identifier will be analysed (.dat files)
Normalisation = False  # If you want to normalise all your values to the first measurement
reference_currents = [49.98, 50.33]  # Measured reference current before and after the measurements
rounding = -1 # If this is > 0, values will be rounded up to the amount of digits given
analysis_type = "batch" # or "long_term"
# Select the desired values here. You can change the units in the brackets and the script will convert them:
columns = ['PCE [%]', 'FF [%]', 'J_SC [mA/cm^2]', 'V_OC [V]', 'T2 [°C]']
'''-------------------------------------------------------------------------------------------------------------------'''
# CHOSE FROM ONE OF THESE VALUES (either Si-units or more specific units'):
columns_raw     = ['name', 'time stamp [s]', 'I_SC [A]', 'V_OC [V]', 'FF []', 'PCE []',
                   'R_shunt [Ohm]', 'I_MPP [A]', 'V_MPP [V]', 'MPP [W]', 'P_in [W]', 'J_SC [A/m^2]']
columns_adapted = ['time stamp [min]', 'I_SC [mA]', 'V_OC [mV]', 'FF [%]', 'PCE [%]',
                   'R_shunt [kOhm]', 'I_MPP [mA]', 'V_MPP [mV]', 'MPP [mW]', 'P_in [mW]', 'J_SC [mA/cm^2]']
sensor_list     = ['T1 [°C]', 'T2 [°C]', 'Irr1 [a.U.]', 'Irr2 [a.U.]']  # Sensor data might not be available
complete_list = columns_raw + columns_adapted + sensor_list

''' These values are usually unchanged '''
A_mask = 16.35 # Illuminated pixel area which is defined by the mask geometry [mm^2]  # 7.9
I_cal = 51.86 # Calibrated SC current of the Si reference cell [mA] 47.98
P_spectrum = 1000  # for AM1.5 1000 [W/m^2]
pixel_num = 6  # alternatively: 8

''' Main Function: change the function call of the PostAnalysis() object depending on what you want to analyse '''
def main():
    # The path with the measurement data:
    dir_path = open_directory()
    # The path where the data should be saved:
    save_path = dir_path
    A = PostAnalysis(dir_path, save_path, ident, reference_currents, columns)
    if analysis_type == "batch":
        A.analyse_batch_measurement()
    elif analysis_type == "long_term":
        A.analyse_repetition_measurements()
    else:
        print("Unknown analysis type.")


''' Auxiliary functions '''
def open_directory():
    # Open file dialog and put it in foreground
    root = Tk()
    root.withdraw()
    root.wm_attributes('-topmost', 1)
    folder_path = filedialog.askdirectory()
    root.destroy()
    return folder_path


def file_name_of(path):
    return os.path.split(path)[1]


def folder_path_of(path):
    return os.path.split(path)[0]


def timestamp(path):
    return os.path.getmtime(path)  # os.path.getctime(path)


''' PostAnalysis Class '''
class PostAnalysis:
    def __init__(self, dir_path, save_path, identifier, reference_currents=None, columns=None):
        # Which files should be analysed?
        self.identifier = identifier
        self.file_extension = ".dat"
        # Which values should be saved?
        self.column_titles = columns
        # Check if the column titles are a legitimate
        for col in columns:
            if col not in complete_list:
                raise ValueError("Desired column title {0} is not a valid parameter. Can't do magic.".format(col))
        # Directory path that is browsed
        self.dir_path = dir_path
        # Directory path where the results are saved
        self.save_path = save_path
        # The paths to the files that will contain the results
        self.saveFile_paths = self.get_saveFile_paths(save_path)
        # Paths of all files in the directory sorted by date/time of creation
        self.paths = sorted(Path(dir_path).iterdir(), key=timestamp)
        self.reference_currents = reference_currents
        # Todo: option to read reference currents directly from reference measurement
        # Time stamp of the first file is assumed to be the starting time of the measurement
        self.starting_time = self.get_starting_time()
        # Check if any file was found
        if self.starting_time is None:
            raise FileNotFoundError(
                "No file name with the identifier {0} found in the given directory".format(self.identifier))
        # Total duration of the measurement
        finishing_time = self.get_finishing_time()
        self.measurement_duration = finishing_time - self.starting_time
        # If the user wants to normalise the data, this property will save the values of the first measurement
        self.initial_values = dict()  # The initial values will be filled when the first file is analysed

    def get_saveFile_paths(self, dir_path):
        saveFile_paths = dict()
        # For all possible 8 pixels
        for i in range(1, 9):
            pixel = str(i)
            # Construct the file name and modify it if normalisation is required
            saveFile_name = self.identifier + "_px" + pixel + "_long_term"
            if Normalisation:
                saveFile_name += "_normalised"
            # Full path, with folder which is defined by the user
            saveFile_path_pixel = os.path.join(dir_path, saveFile_name + ".csv")
            # There should not already exist a file like that (append mode will ruin it)
            if os.path.exists(saveFile_path_pixel):
                raise FileExistsError("The file {0} already exists!".format(saveFile_name))
            # Fill the dictionary with the path, where the key is the pixel
            saveFile_paths[pixel] = saveFile_path_pixel
        return saveFile_paths

    def get_starting_time(self):
        # Look for the first file with the given identifier
        for path in self.paths:
            file_name = file_name_of(path)
            if self.identifier in file_name and self.file_extension in file_name:
                print("first file: {0} \n".format(file_name_of(path)))
                # time stamp of that file is defining the starting point of the measurement
                return timestamp(path)
        return None

    def get_finishing_time(self):
        # Look for the last file with the given identifier
        for path in reversed(self.paths):
            file_name = file_name_of(path)
            if self.identifier in file_name and self.file_extension in file_name:
                print("last file: {0} \n".format(file_name_of(path)))
                # time stamp of that file is defining the finishing point of the measurement
                return timestamp(path)
        return None

    def input_power(self, path):
        ref0 = self.reference_currents[0]  # reference current before the measurements
        ref1 = self.reference_currents[1]  # reference current after the measurements
        # time in seconds that this file was created
        t = timestamp(path) - self.starting_time
        # Interpolation between the two measurements based on time
        ref_real = ref0 + (ref1 - ref0) * t / self.measurement_duration
        # Calculation of received power
        return P_spectrum * ref_real / I_cal

    def get_sensor_data(self, data):
        if len(data.columns) == 6:
            intensity = list(data[4])
            temperature = list(data[5])

            i_first = intensity[20]
            T_first = temperature[20]
            i_last = intensity[-1]
            T_last = temperature[-1]

            sensor_dict = {'T1 [°C]': T_first, 'T2 [°C]': T_last, 'Irr1 [a.U.]': i_first, 'Irr2 [a.U.]': i_last}
            return sensor_dict.copy()
        else:
            return dict().copy()


    def calculate_electrical_characteristics(self, path):
        file_name = file_name_of(path)[:-len(self.file_extension)]
        data = DataFrame(loadtxt(path, dtype=float))
        voltage = data[0]  # [V]
        current = data[1]  # [A]
        power = data[2]  # [P]

        # time of creation of the file
        time_stamp = timestamp(path) - self.starting_time
        # interpolate the data
        I_spline = UnivariateSpline(voltage, current, k=5, s=0)
        P_spline = UnivariateSpline(voltage, power, k=5, s=0)
        # Short circuit current and current density
        I_SC = -1 * I_spline(0)
        J_SC = I_SC / A_mask * 1e6  # [A/m^2]
        # open circuit voltage
        V_OC = float(fsolve(I_spline, max(voltage))[0])
        # Maximum Power Point (MPP) values:
        min_power_V = data[data[2] == min(data[2])][0]
        V_MPP = float(fmin(P_spline, min_power_V, disp=None)[0])  # voltage at the MPP in V
        I_MPP = -I_spline(V_MPP)  # current at the MPP in A
        P_MPP = -P_spline(V_MPP)  # power at the MPP in W
        # Fill factor and efficiency:
        FF = P_MPP / (I_SC * V_OC)
        P_in = self.input_power(path) * A_mask / 1e6  # [W]
        PCE = P_MPP / P_in
        # Check the PCE value to give feedback to the user
        if 0.15 < PCE < 1:
            warnings.warn("PCE value of {0} is high, check for the following possible issues: "
                          "given cell area is too small, reference currents are too low, data is garbled".format(PCE))
        elif PCE < 0 or PCE > 1:
            warnings.warn("Implausible PCE of {0}: value out of range!".format(PCE))

        # Shunt resistance
        dR = I_spline.derivative()
        R_shunt = 1 / float(dR(0))  # [Ohm]

        values = {'name': file_name,
                  'time stamp [s]': time_stamp, 'I_SC [A]': I_SC, 'V_OC [V]': V_OC, 'FF []': FF, 'PCE []': PCE,
                  'time stamp [min]': time_stamp / 60, 'I_SC [mA]': I_SC * 1e3, 'V_OC [mV]': V_OC * 1e3,
                  'FF [%]': FF * 100, 'PCE [%]': PCE * 100,
                  'R_shunt [Ohm]': R_shunt, 'I_MPP [A]': I_MPP, 'V_MPP [V]': V_MPP, 'MPP [W]': P_MPP, 'P_in [W]': P_in,
                  'J_SC [A/m^2]': J_SC,
                  'R_shunt [kOhm]': R_shunt / 1e3, 'I_MPP [mA]': I_MPP * 1e3, 'V_MPP [mV]': V_MPP * 1e3,
                  'MPP [mW]': P_MPP * 1e3, 'P_in [mW]': P_in * 1e3, 'J_SC [mA/cm^2]': J_SC / 10
                  }
        values.update(self.get_sensor_data(data))
        # A subset of the dictionary based on the values the user is interested in
        selected_values = {key: values[key] for key in self.column_titles}
        # Round the values in the dictionary
        if rounding > 0:
            for element in selected_values:
                # Only round values that are not strings
                if not isinstance(selected_values[element], str):
                    selected_values[element] = round(selected_values[element], rounding)

        return selected_values

    def normalise(self, values, pixel):
        # values is a dictionary with the calculated electrical/optical characteristics
        for element in values:
            # Check if the entry in the dict is a string or a time value
            if not isinstance(values[element], str) and 'time' not in element:
                # Normalise the value in the dict according to the first measurement
                values[element] = values[element] / self.initial_values[pixel][element]
        return values

    def analyse_batch_measurement(self):
        pixel_list = list(range(1,pixel_num+1))
        # create a dictionary consisting of the user defined column titles as keys and empty DataFrames as values
        data_dict = dict((k, DataFrame({"Pixel":pixel_list}).set_index("Pixel")) for k in self.column_titles)
        for file_path in self.paths:
            file_name = file_name_of(file_path)
            try:
                if self.identifier in file_name and self.file_extension in file_name:
                    # Remove file suffix
                    file_name = file_name[:-len(self.file_extension)]
                    # extract sample name and pixel index
                    file_parts = file_name.split("_")
                    sample_name = ""
                    pixel_index = -1
                    for part in file_parts:
                        # Extract the pixel index from the name px?
                        if part[-1] in [str(c) for c in pixel_list] and part[0:2] == "px":
                            pixel_index = int(part[-1])  # - 1
                        else:
                            # Reconstruct the sample name from the file name but remove the pixel number
                            sample_name += part + "_"
                    # Just remove the last "_"
                    sample_name = sample_name[:-1]

                    # get the value of the desired variable
                    value_dict = self.calculate_electrical_characteristics(file_path)
                    for value_name in self.column_titles:
                        data = data_dict[value_name]  # data is not a copy but a reference to an object in data_dict
                        # Fill up data frame, use sample name as column and pixel_index as row
                        if sample_name in data.columns:
                            # This column already exist, so just update the value
                            data.loc[pixel_index, sample_name] = value_dict[value_name]
                        else:
                            # Add a column with the sample name and fill it with 0
                            data[sample_name] = [0] * pixel_num
                            data.loc[pixel_index, sample_name] = value_dict[value_name]
            except Exception as ex:
                print("Error occurred when reading file {0}\n".format(file_name))
                print(ex)

        for value_name in self.column_titles:
            data = data_dict[value_name].transpose()
            # Windows doesn't allow all characters to be used in file names (/\"*:<>)
            value_name = value_name.replace("/"," ").replace("*", "")  # .replace(...).replace(...)...
            data.to_csv(path_or_buf= self.save_path + "/" + value_name + "_overview.csv", sep=';', index=True)

    def analyse_repetition_measurements(self):
        i = 0  # Just a counter to tell the user how long it still takes
        i_max = len(self.paths)
        for file_path in self.paths:
            file_name = file_name_of(file_path)
            # try:
            # Check for identifier in file name and correct extension
            if self.file_extension in file_name and self.identifier in file_name:
                pixel = file_name[file_name.find("px") + 2]  # extract pixel from file name
                values = self.calculate_electrical_characteristics(file_path)
                # save the values in the corresponding file. There is a file for each pixel
                if not os.path.exists(self.saveFile_paths[pixel]):
                    write_header = True
                    # print("File created:\n", self.saveFile_paths[pixel])
                    # Since the file is created here, it means the very first measurement file for that pixel was analysed
                    if Normalisation:
                        # Therefore: save the calculated values as initial values for that pixel for normalisation
                        self.initial_values[pixel] = values.copy()
                else:
                    write_header = False

                # Open the file in append modus
                with open(self.saveFile_paths[pixel], 'a', encoding="UTF-8", newline='') as csvfile:
                    writer = csv.DictWriter(csvfile, fieldnames=self.column_titles, delimiter=";")
                    # If the file doesn't exist yet, the titles have to be written first
                    if write_header:
                        writer.writeheader()
                    # Check whether the values need to be given in normalised form
                    if Normalisation:
                        writer.writerow(self.normalise(values, pixel))
                    else:
                        writer.writerow(values)

            # Display the progress. Update roughly every 5%
            if i % int(i_max/20) == 0:
                print("Progress: {0:.1f} %".format(i / i_max * 100))
            i += 1

            '''except Exception as ex:
                print("Error occurred when reading file {0}\n".format(file_name))
                print(ex)'''


if __name__ == '__main__':
    main()
